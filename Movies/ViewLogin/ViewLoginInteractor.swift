//
//  ViewLoginInteractor.swift
//  PeliculasNewTiss
//
//  Created Administrator on 12/04/23.
//  Copyright © 2023 ___ORGANIZATIONNAME___. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
//                Delegados del URLSesion
class ViewLoginInteractor: NSObject, URLSessionDelegate,URLSessionDataDelegate{
    //MARK: - Protocol Properties
    weak var presenter: ViewLoginPresenterProtocol?
    
    private var dataTask : URLSessionDataTask?
        private var responseData : Data = Data()
        private var httpResponse : HTTPURLResponse?
        
        override init() {
            super.init()
        }
}

//MARK: - Interactor Methods
extension ViewLoginInteractor: ViewLoginInteractorProtocol {
     
    
    func initToken(pass: String, user: String){
        let urlString = ConstantesPelis.API_TOKEN
            if let url = URL(string: urlString) {
                Task {
                    if  let data = try? Data(contentsOf: url){
                         let decod = JSONDecoder()
                        if let datDecod = try? decod.decode(TokenResponse.self, from: data){
                            print("Respuesta token",datDecod)
                            initLogin(token: datDecod.requestToken, user: user, pass: pass)
                            
                        }else{
                            print("Respuesta token fail")
//                            presenter?.tokenFail()
                            
                        }
                    }
                }
            }
        }
    func initLogin(token:String,user: String,pass:String){

            let urlString = ConstantesPelis.API_LOGIN
            let parameters = "{\"username\":\"\(user)\",\"password\":\"\(pass)\",\"request_token\":\"\(token)\"}"
            let postData = parameters.data(using: .utf8)
            guard let url = URL(string: urlString) else {return}
            var request = URLRequest(url: url,timeoutInterval: Double.infinity)
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.httpMethod = "POST"
            request.httpBody = postData

            let sessionConfoguration = URLSessionConfiguration.default
            let defaultSession = URLSession(configuration: sessionConfoguration, delegate: self, delegateQueue: OperationQueue.main)

            dataTask = defaultSession.dataTask(with: request)
            dataTask?.resume()
            responseData = Data()
        }
    
    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
            if error == nil{
                if httpResponse?.statusCode == 200{
                    let response = String(data: responseData, encoding: String.Encoding.utf8)
                    if let _ = response{
                        do{
                            let responseLogin = try
                            JSONDecoder().decode(TokenResponse.self, from: responseData)
                            print("Respuesta Ok ::::::::::::::::::::::: \(responseLogin)")
                            presenter?.loginSuccess()
                            
                        }catch{
                            print("Error creando objetos \(error)")
                            presenter?.loginFiel()
                        }
                    }else{
                        print("Error en crear string\(String(describing: error))")
                        presenter?.loginFiel()
                    }
                    
                }else{
                    print("http diferente de 200\(String(describing: error))")
                    presenter?.loginFiel()
                }
            }else{
                print("El error no fue nil\(String(describing: error))")
                presenter?.loginFiel()
            }
        }
        
        func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
            responseData.append(data)
        }
      
        func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -> Void) {
            httpResponse = response as? HTTPURLResponse
            completionHandler(URLSession.ResponseDisposition.allow)
        }
        
    }


